# -*- coding: utf-8 -*-
"""ASIYR.ipynb

Automatically generated by Colaboratory.

Original file is located at
	https://colab.research.google.com/drive/1SGIlj4XKkN0zO5SWlm89M_OvAfwzw4Uh
"""

# !pip install tikzplotlib
import numpy as np
import random
import math
# import matplotlib.pyplot as plt
from numpy import linalg as LA
from google.colab import files
#import tikzplotlib

import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt

import networkx as nx
import subprocess
import os
import moviepy.editor as mp
import shutil
q=1
G = nx.Graph()
c1 = []
c2 = []
c3 = []




from flask import Flask, jsonify, render_template, request
app = Flask(__name__)

@app.route("/")
def main():
	return render_template('main.html',n = '50')

@app.route("/simulation")
def sim():
	a = request.args.get('js')
	main(int(a))
	return render_template('main0.html',n=str(a))

def pnum( x ):
	qu = x/24
	r = x%24
	if r==0:
		qu = qu-1
		r=24
	x = str(qu+1)+chr(r+96)
	return x;

def activateNodes(isActivatedNode,currentState,activity,adaptation,n):
	for i in range(0,n):
		if(currentState[i][1] == 1):
			isActivatedNode[i] = np.random.binomial(1,activity[i]*adaptation[i])
		else:
			isActivatedNode[i] = np.random.binomial(1,activity[i])

def activateLinks(adjMat,isActivatedNode,currentState,activity,acceptance,degree,n):

	for i in range(0,n):
		if(isActivatedNode[i]):
			nodeToLink = []
			for j in range(0,n):
				if(i != j):
					nodeToLink.append(j)
			for j in range(1,degree[i]+1):
				x = np.random.randint(0,n-j)
				if(currentState[nodeToLink[x]][1] == 1):
					y = np.random.binomial(1,acceptance[nodeToLink[x]])
					adjMat[i][nodeToLink[x]] = y
					adjMat[nodeToLink[x]][i] = y
				else:
					adjMat[i][nodeToLink[x]] = 1
					adjMat[nodeToLink[x]][i] = 1
				temp = nodeToLink[x]
				nodeToLink[x] = nodeToLink[n-j-1]
				nodeToLink[n-j-1] = temp

def simulate_A_SIYR(n,currentState,degree,activity,adaptation,acceptance,delta,beta,nu):

	global q
	global G
	global c2
	c1 = []
	c3 = []

	# print currentState

	isActivatedNode = np.zeros((n,1))
	activateNodes(isActivatedNode,currentState,activity,adaptation,n)
	for i in range(0,n):
		G.add_node(i)
		if isActivatedNode[i] == 1:
			c1.append("black");
		else:
			c1.append(c2[i]);

	nx.draw_shell(G, with_labels=False, font_weight='bold',node_color=c1,node_size=40,width=0.2)

	plt.savefig(pnum(q)+".png")
	q=q+1

	adjMat = np.zeros((n,n))
	activateLinks(adjMat,isActivatedNode,currentState,activity,acceptance,degree,n)

	for i in range(0,n):
		for j in range(0,n):
			if(adjMat[i][j]==1):
				G.add_edge(i,j)

	nx.draw_shell(G, with_labels=False, font_weight='bold',node_color=c1,node_size=40,width=0.2)
	plt.savefig(pnum(q)+".png")
	q=q+1

	nextState = np.zeros((n,3))


	for i in range(0,n):
		recoveryX  = np.random.binomial(1,delta[0])
		recoveryY  = np.random.binomial(1,delta[1])
		conversion = np.random.binomial(1,nu)
		result = 1
		for j in range(0,n):
			if (i == j):
				continue
			infectionX = np.random.binomial(1,beta[0])
			infectionY = np.random.binomial(1,beta[1])
			result = result * (1 - adjMat[i][j]*(currentState[j][0]*infectionX + currentState[j][1]*infectionY))

		nextState[i][0] = (1-recoveryX)*(1-conversion)*currentState[i][0] + (1-result)*(1 - currentState[i][0] - currentState[i][1]-currentState[i][2])
		nextState[i][1] = (1-recoveryX)*(conversion)*currentState[i][0] + (1-recoveryY)*(currentState[i][1])
		nextState[i][2] = currentState[i][2] + recoveryX*currentState[i][0] + recoveryY *currentState[i][1]

	# print (nextState)

	for i in range(0,n):
				if(nextState[i][0] == 1):
					c3.append("orange")
				elif(nextState[i][1] == 1):
					c3.append("red")
				elif(nextState[i][2] == 1):
					c3.append("green")
				else:
					c3.append("yellow")
	nx.draw_shell(G, with_labels=False, font_weight='bold',node_color=c3,node_size=40,width=0.2)

	plt.savefig(pnum(q)+".png")
	q=q+1
	c2 = c3
	G.clear()
	plt.close()
	return nextState

def calcNorm(p,n,st):
	x = 0
	for i in range(0,n):
		x += abs(p[i][st])

	return x

def main(a):
	# define number of nodes
	n = a
	global c2
	global G
	# intialise activity, adaptation and acceptance rates of each node
	activity = np.zeros((n,1))
	adaptation = np.zeros((n,1))
	acceptance = np.zeros((n,1))
	# 0,1,2 represents asymptomatic, symptomatic and recovered respectively.
	state = np.zeros((n,3))
	degree = []
	# mbar = degree/(n-1);
	mbar = np.zeros((n,1))

	#beta
	infectionRate = np.zeros((2,1))
	#gamma
	recoveryRate = np.zeros((2,1))

	recoveryRate[0] = 0.2
	recoveryRate[1] = 0.2
	infectionRate[0] = 0.25
	infectionRate[1] = 0.25

	# rate of converting from asymptomatic to symptomatic(nu)
	conversionRate = 0.15


	#change the parameters
	for i in range(0,n):
		if(i < 20):
			state[i][0] = 1
		if(i >= 45):
			state[i][1] = 1
		degree.append(6)
		activity[i]   = 0.2
		adaptation[i] = 0.5
		acceptance[i] = 0.5
		mbar[i] =(1.0*degree[i])/(n-1)

	betax = np.zeros((n,n))
	betay = np.zeros((n,n))

	for i in range(0,n):
		for j in range(0,n):
			betay[i][j] = infectionRate[1]*(1-(1-activity[i]*mbar[i]*acceptance[j])*(1-activity[j]*adaptation[j]*mbar[j]))
			betax[i][j] = infectionRate[0]*(1-(1-activity[i]*mbar[i])*(1-activity[j]*mbar[j]))

	ci = []
	for i in range(0,n):
				G.add_node(i)
				if(state[i][0] == 1):
					ci.append("orange")
				elif(state[i][1] == 1):
					ci.append("red")
				elif(state[i][2] == 1):
					ci.append("green")
				else:
					ci.append("yellow")
	c2 = ci
	nx.draw_shell(G, with_labels=False, font_weight='bold',node_color=ci,node_size=40,width=0.2)

	plt.savefig('1'+".png")

	G.clear()

	plt.close()

	# print betax
	# print betay

	#Calculate Upper bound
	# bound(n,recoveryRate,conversionRate,betax,betay)

	total_runs = 1
	total_time = 50

	#increase in steps of conversion Rate
	change = 1

	#simulate A-SIYR
	while(conversionRate <= 1):
		simulation = 0
		probability = np.zeros((total_time,n,3))
		currentState = np.zeros((n,3))
		while(simulation < total_runs):
			currentState = state
			time = 0
			while(time < total_time):
				for i in range(0,n):
					for j in range(0,3):
						probability[time][i][j] += currentState[i][j]
				nextState = simulate_A_SIYR(n,currentState,degree,activity,adaptation,acceptance,recoveryRate,infectionRate,conversionRate)
				time += 1
				currentState = nextState
				# print currentState
			simulation += 1
			# print (simulation)

		times = []
		for t in range(0,total_time):
			for i in range(0,n):
				for j in range(0,3):
					probability[t][i][j] /= total_runs

		# print (probability)
		norm = np.zeros((3,total_time))
		for t in range(0,total_time):
			for i in range(0,3):
				x = calcNorm(probability[t],n,i)
				x = x/n
				norm[i][t] = x
			times.append(t)


		folder_path = os.getcwd()
		test = os.listdir(folder_path)
		test1 = os.listdir(folder_path+"/static")

		for images in test1:
			if images.endswith(".gif"):
				os.remove(os.path.join(folder_path+"/static", images))

		for image in test1:
			if image.endswith(".mp4"):
				os.remove(os.path.join(folder_path+"/static", image))

		for image in test1:
			if image.endswith(".jpg"):
				os.remove(os.path.join(folder_path+"/static", image))

		i = "*.png"
		o = str(n)+".gif"
		subprocess.call("convert -delay 150 -loop 5 " + i + " " + o, shell=True)
		os.system("start " + str(n)+".gif")

		clip = mp.VideoFileClip(str(n)+ ".gif")
		clip.write_videofile(str(n)+".mp4")

		for images in test:
			if images.endswith(".png"):
				os.remove(os.path.join(folder_path, images))

		shutil.move( folder_path+'/'+str(n)+'.mp4' , folder_path + '/static/' +str(n)+'.mp4')
		shutil.move( folder_path+'/'+str(n)+'.gif' , folder_path + '/static/' +str(n)+'.gif')

		fig = plt.figure()
		ax = fig.add_subplot(1, 1, 1)


		# for i in range(0,2):
		#     print (norm[i])
		# print(conversionRate)

		ax.plot(times,1 - norm[0] - norm[1] - norm[2], label = "S")
		ax.plot(times,norm[0], label = "X")
		ax.plot(times,norm[1], label = "Y")
		ax.plot(times,norm[2], label = "R")
		plt.legend(loc = "upper right")
		plt.title("x_initial = 20", fontsize=15)
		plt.xlabel('Time', fontsize=15)
		plt.ylabel('Fraction Infected', fontsize=15)
		plt.style.use("default")
		plt.savefig(str(n)+".jpg")
		shutil.move( folder_path+'/'+str(n)+'.jpg' , folder_path + '/static/' +str(n)+'.jpg')
		conversionRate += change




# if __name__ == "__main__":
# 	main()

if __name__ == "__main__":
	app.run()
